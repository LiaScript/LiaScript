function t(t){if(!Number.isSafeInteger(t)||t<0)throw Error("positive integer expected, got "+t)}function e(t,...e){if(!((r=t)instanceof Uint8Array||ArrayBuffer.isView(r)&&"Uint8Array"===r.constructor.name))throw Error("Uint8Array expected");var r;if(e.length>0&&!e.includes(t.length))throw Error("Uint8Array expected of length "+e+", got length="+t.length)}function r(t,e=!0){if(t.destroyed)throw Error("Hash instance has been destroyed");if(e&&t.finished)throw Error("Hash#digest() has already been called")}const n="object"==typeof globalThis&&"crypto"in globalThis?globalThis.crypto:void 0;function o(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function i(t,e){return t<<32-e|t>>>e}function s(t){return"string"==typeof t&&(t=function(t){if("string"!=typeof t)throw Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array((new TextEncoder).encode(t))}(t)),e(t),t}class a{clone(){return this._cloneInto()}}function c(t){const e=e=>t().update(s(e)).digest(),r=t();return e.outputLen=r.outputLen,e.blockLen=r.blockLen,e.create=()=>t(),e}function u(t=32){if(n&&"function"==typeof n.getRandomValues)return n.getRandomValues(new Uint8Array(t));if(n&&"function"==typeof n.randomBytes)return n.randomBytes(t);throw Error("crypto.getRandomValues must be defined")}function f(t,e,r){return t&e^t&r^e&r}class l extends a{constructor(t,e,r,n){super(),this.blockLen=t,this.outputLen=e,this.padOffset=r,this.isLE=n,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(t),this.view=o(this.buffer)}update(t){r(this);const{view:e,buffer:n,blockLen:i}=this,a=(t=s(t)).length;for(let r=0;r<a;){const s=Math.min(i-this.pos,a-r);if(s!==i)n.set(t.subarray(r,r+s),this.pos),this.pos+=s,r+=s,this.pos===i&&(this.process(e,0),this.pos=0);else{const e=o(t);for(;i<=a-r;r+=i)this.process(e,r)}}return this.length+=t.length,this.roundClean(),this}digestInto(t){r(this),function(t,r){e(t);const n=r.outputLen;if(t.length<n)throw Error("digestInto() expects output buffer of length at least "+n)}(t,this),this.finished=!0;const{buffer:n,view:i,blockLen:s,isLE:a}=this;let{pos:c}=this;n[c++]=128,this.buffer.subarray(c).fill(0),this.padOffset>s-c&&(this.process(i,0),c=0);for(let t=c;t<s;t++)n[t]=0;!function(t,e,r,n){if("function"==typeof t.setBigUint64)return t.setBigUint64(e,r,n);const o=BigInt(32),i=BigInt(4294967295),s=Number(r>>o&i),a=Number(r&i),c=n?4:0,u=n?0:4;t.setUint32(e+c,s,n),t.setUint32(e+u,a,n)}(i,s-8,BigInt(8*this.length),a),this.process(i,0);const u=o(t),f=this.outputLen;if(f%4)throw Error("_sha2: outputLen should be aligned to 32bit");const l=f/4,d=this.get();if(l>d.length)throw Error("_sha2: outputLen bigger than state");for(let t=0;t<l;t++)u.setUint32(4*t,d[t],a)}digest(){const{buffer:t,outputLen:e}=this;this.digestInto(t);const r=t.slice(0,e);return this.destroy(),r}_cloneInto(t){t||(t=new this.constructor),t.set(...this.get());const{blockLen:e,buffer:r,length:n,finished:o,destroyed:i,pos:s}=this;return t.length=n,t.pos=s,t.finished=o,t.destroyed=i,n%e&&t.buffer.set(r),t}}const d=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),h=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),p=new Uint32Array(64);class y extends l{constructor(){super(64,32,8,!1),this.A=0|h[0],this.B=0|h[1],this.C=0|h[2],this.D=0|h[3],this.E=0|h[4],this.F=0|h[5],this.G=0|h[6],this.H=0|h[7]}get(){const{A:t,B:e,C:r,D:n,E:o,F:i,G:s,H:a}=this;return[t,e,r,n,o,i,s,a]}set(t,e,r,n,o,i,s,a){this.A=0|t,this.B=0|e,this.C=0|r,this.D=0|n,this.E=0|o,this.F=0|i,this.G=0|s,this.H=0|a}process(t,e){for(let r=0;r<16;r++,e+=4)p[r]=t.getUint32(e,!1);for(let t=16;t<64;t++){const e=p[t-15],r=p[t-2],n=i(e,7)^i(e,18)^e>>>3,o=i(r,17)^i(r,19)^r>>>10;p[t]=o+p[t-7]+n+p[t-16]|0}let{A:r,B:n,C:o,D:s,E:a,F:c,G:u,H:l}=this;for(let t=0;t<64;t++){const e=l+(i(a,6)^i(a,11)^i(a,25))+((h=a)&c^~h&u)+d[t]+p[t]|0,y=(i(r,2)^i(r,13)^i(r,22))+f(r,n,o)|0;l=u,u=c,c=a,a=s+e|0,s=o,o=n,n=r,r=e+y|0}var h;r=r+this.A|0,n=n+this.B|0,o=o+this.C|0,s=s+this.D|0,a=a+this.E|0,c=c+this.F|0,u=u+this.G|0,l=l+this.H|0,this.set(r,n,o,s,a,c,u,l)}roundClean(){p.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const g=c((()=>new y));class m extends a{constructor(e,r){super(),this.finished=!1,this.destroyed=!1,function(e){if("function"!=typeof e||"function"!=typeof e.create)throw Error("Hash should be wrapped by utils.wrapConstructor");t(e.outputLen),t(e.blockLen)}(e);const n=s(r);if(this.iHash=e.create(),"function"!=typeof this.iHash.update)throw Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const o=this.blockLen,i=new Uint8Array(o);i.set(n.length>o?e.create().update(n).digest():n);for(let t=0;t<i.length;t++)i[t]^=54;this.iHash.update(i),this.oHash=e.create();for(let t=0;t<i.length;t++)i[t]^=106;this.oHash.update(i),i.fill(0)}update(t){return r(this),this.iHash.update(t),this}digestInto(t){r(this),e(t,this.outputLen),this.finished=!0,this.iHash.digestInto(t),this.oHash.update(t),this.oHash.digestInto(t),this.destroy()}digest(){const t=new Uint8Array(this.oHash.outputLen);return this.digestInto(t),t}_cloneInto(t){t||(t=Object.create(Object.getPrototypeOf(this),{}));const{oHash:e,iHash:r,finished:n,destroyed:o,blockLen:i,outputLen:s}=this;return t.finished=n,t.destroyed=o,t.blockLen=i,t.outputLen=s,t.oHash=e._cloneInto(t.oHash),t.iHash=r._cloneInto(t.iHash),t}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const w=(t,e,r)=>new m(t,e).update(r).digest();w.create=(t,e)=>new m(t,e);const b=BigInt(0),E=BigInt(1),v=BigInt(2);function B(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&"Uint8Array"===t.constructor.name}function A(t){if(!B(t))throw Error("Uint8Array expected")}function x(t,e){if("boolean"!=typeof e)throw Error(t+" boolean expected, got "+e)}const S=Array.from({length:256},((t,e)=>e.toString(16).padStart(2,"0")));function I(t){A(t);let e="";for(let r=0;r<t.length;r++)e+=S[t[r]];return e}function k(t){const e=t.toString(16);return 1&e.length?"0"+e:e}function P(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);return""===t?b:BigInt("0x"+t)}const T=48,O=57,L=65,R=70,U=97,N=102;function q(t){return t>=T&&t<=O?t-T:t>=L&&t<=R?t-(L-10):t>=U&&t<=N?t-(U-10):void 0}function H(t){if("string"!=typeof t)throw Error("hex string expected, got "+typeof t);const e=t.length,r=e/2;if(e%2)throw Error("hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(r);for(let e=0,o=0;e<r;e++,o+=2){const r=q(t.charCodeAt(o)),i=q(t.charCodeAt(o+1));if(void 0===r||void 0===i){const e=t[o]+t[o+1];throw Error('hex string expected, got non-hex character "'+e+'" at index '+o)}n[e]=16*r+i}return n}function C(t){return P(I(t))}function D(t){return A(t),P(I(Uint8Array.from(t).reverse()))}function z(t,e){return H(t.toString(16).padStart(2*e,"0"))}function F(t,e){return z(t,e).reverse()}function j(t,e,r){let n;if("string"==typeof e)try{n=H(e)}catch(e){throw Error(t+" must be hex string or Uint8Array, cause: "+e)}else{if(!B(e))throw Error(t+" must be hex string or Uint8Array");n=Uint8Array.from(e)}const o=n.length;if("number"==typeof r&&o!==r)throw Error(t+" of length "+r+" expected, got "+o);return n}function V(...t){let e=0;for(let r=0;r<t.length;r++){const n=t[r];A(n),e+=n.length}const r=new Uint8Array(e);for(let e=0,n=0;e<t.length;e++){const o=t[e];r.set(o,n),n+=o.length}return r}const Z=t=>"bigint"==typeof t&&b<=t;function K(t,e,r){return Z(t)&&Z(e)&&Z(r)&&e<=t&&t<r}function _(t,e,r,n){if(!K(e,r,n))throw Error("expected valid "+t+": "+r+" <= n < "+n+", got "+e)}function M(t){let e;for(e=0;t>b;t>>=E,e+=1);return e}const G=t=>(v<<BigInt(t-1))-E,$=t=>new Uint8Array(t),Y=t=>Uint8Array.from(t);function W(t,e,r){if("number"!=typeof t||t<2)throw Error("hashLen must be a number");if("number"!=typeof e||e<2)throw Error("qByteLen must be a number");if("function"!=typeof r)throw Error("hmacFn must be a function");let n=$(t),o=$(t),i=0;const s=()=>{n.fill(1),o.fill(0),i=0},a=(...t)=>r(o,n,...t),c=(t=$())=>{o=a(Y([0]),t),n=a(),0!==t.length&&(o=a(Y([1]),t),n=a())},u=()=>{if(i++>=1e3)throw Error("drbg: tried 1000 values");let t=0;const r=[];for(;t<e;){n=a();const e=n.slice();r.push(e),t+=n.length}return V(...r)};return(t,e)=>{let r;for(s(),c(t);!(r=e(u()));)c();return s(),r}}const J={bigint(t){return"bigint"==typeof t},function(t){return"function"==typeof t},boolean(t){return"boolean"==typeof t},string(t){return"string"==typeof t},stringOrUint8Array(t){return"string"==typeof t||B(t)},isSafeInteger(t){return Number.isSafeInteger(t)},array(t){return Array.isArray(t)},field(t,e){return e.Fp.isValid(t)},hash(t){return"function"==typeof t&&Number.isSafeInteger(t.outputLen)}};function Q(t,e,r={}){const n=(e,r,n)=>{const o=J[r];if("function"!=typeof o)throw Error("invalid validator function");const i=t[e];if(!(n&&void 0===i||o(i,t)))throw Error("param "+e+" is invalid. Expected "+r+", got "+i)};for(const[t,r]of Object.entries(e))n(t,r,!1);for(const[t,e]of Object.entries(r))n(t,e,!0);return t}function X(t){const e=new WeakMap;return(r,...n)=>{const o=e.get(r);if(void 0!==o)return o;const i=t(r,...n);return e.set(r,i),i}}var tt=Object.freeze({__proto__:null,aInRange:_,abool:x,abytes:A,bitGet(t,e){return t>>BigInt(e)&E},bitLen:M,bitMask:G,bitSet(t,e,r){return t|(r?E:b)<<BigInt(e)},bytesToHex:I,bytesToNumberBE:C,bytesToNumberLE:D,concatBytes:V,createHmacDrbg:W,ensureBytes:j,equalBytes(t,e){if(t.length!==e.length)return!1;let r=0;for(let n=0;n<t.length;n++)r|=t[n]^e[n];return 0===r},hexToBytes:H,hexToNumber:P,inRange:K,isBytes:B,memoized:X,notImplemented(){throw Error("not implemented")},numberToBytesBE:z,numberToBytesLE:F,numberToHexUnpadded:k,numberToVarBytesBE(t){return H(k(t))},utf8ToBytes(t){if("string"!=typeof t)throw Error("string expected");return new Uint8Array((new TextEncoder).encode(t))},validateObject:Q});const et=BigInt(0),rt=BigInt(1),nt=BigInt(2),ot=BigInt(3),it=BigInt(4),st=BigInt(5),at=BigInt(8);function ct(t,e){const r=t%e;return r>=et?r:e+r}function ut(t,e,r){if(e<et)throw Error("invalid exponent, negatives unsupported");if(r<=et)throw Error("invalid modulus");if(r===rt)return et;let n=rt;for(;e>et;)e&rt&&(n=n*t%r),t=t*t%r,e>>=rt;return n}function ft(t,e,r){let n=t;for(;e-- >et;)n*=n,n%=r;return n}function lt(t,e){if(t===et)throw Error("invert: expected non-zero number");if(e<=et)throw Error("invert: expected positive modulus, got "+e);let r=ct(t,e),n=e,o=et,i=rt;for(;r!==et;){const t=n%r,e=o-i*(n/r);n=r,r=t,o=i,i=e}if(n!==rt)throw Error("invert: does not exist");return ct(o,e)}function dt(t){if(t%it===ot){const e=(t+rt)/it;return function(t,r){const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw Error("Cannot find square root");return n}}if(t%at===st){const e=(t-st)/at;return function(t,r){const n=t.mul(r,nt),o=t.pow(n,e),i=t.mul(r,o),s=t.mul(t.mul(i,nt),o),a=t.mul(i,t.sub(s,t.ONE));if(!t.eql(t.sqr(a),r))throw Error("Cannot find square root");return a}}return function(t){const e=(t-rt)/nt;let r,n,o;for(r=t-rt,n=0;r%nt===et;r/=nt,n++);for(o=nt;o<t&&ut(o,e,t)!==t-rt;o++)if(o>1e3)throw Error("Cannot find square root: likely non-prime P");if(1===n){const e=(t+rt)/it;return(t,r)=>{const n=t.pow(r,e);if(!t.eql(t.sqr(n),r))throw Error("Cannot find square root");return n}}const i=(r+rt)/nt;return(t,s)=>{if(t.pow(s,e)===t.neg(t.ONE))throw Error("Cannot find square root");let a=n,c=t.pow(t.mul(t.ONE,o),r),u=t.pow(s,i),f=t.pow(s,r);for(;!t.eql(f,t.ONE);){if(t.eql(f,t.ZERO))return t.ZERO;let e=1;for(let r=t.sqr(f);e<a&&!t.eql(r,t.ONE);e++)r=t.sqr(r);const r=t.pow(c,rt<<BigInt(a-e-1));c=t.sqr(r),u=t.mul(u,r),f=t.mul(f,c),a=e}return u}}(t)}const ht=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function pt(t,e){const r=void 0!==e?e:t.toString(2).length;return{nBitLength:r,nByteLength:Math.ceil(r/8)}}function yt(t,e,r=!1,n={}){if(t<=et)throw Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:o,nByteLength:i}=pt(t,e);if(i>2048)throw Error("invalid field: expected ORDER of <= 2048 bytes");let s;const a=Object.freeze({ORDER:t,isLE:r,BITS:o,BYTES:i,MASK:G(o),ZERO:et,ONE:rt,create(e){return ct(e,t)},isValid(e){if("bigint"!=typeof e)throw Error("invalid field element: expected bigint, got "+typeof e);return et<=e&&e<t},is0(t){return t===et},isOdd(t){return(t&rt)===rt},neg(e){return ct(-e,t)},eql(t,e){return t===e},sqr(e){return ct(e*e,t)},add(e,r){return ct(e+r,t)},sub(e,r){return ct(e-r,t)},mul(e,r){return ct(e*r,t)},pow(t,e){return function(t,e,r){if(r<et)throw Error("invalid exponent, negatives unsupported");if(r===et)return t.ONE;if(r===rt)return e;let n=t.ONE,o=e;for(;r>et;)r&rt&&(n=t.mul(n,o)),o=t.sqr(o),r>>=rt;return n}(a,t,e)},div(e,r){return ct(e*lt(r,t),t)},sqrN(t){return t*t},addN(t,e){return t+e},subN(t,e){return t-e},mulN(t,e){return t*e},inv(e){return lt(e,t)},sqrt:n.sqrt||(e=>(s||(s=dt(t)),s(a,e))),invertBatch(t){return function(t,e){const r=Array(e.length),n=e.reduce(((e,n,o)=>t.is0(n)?e:(r[o]=e,t.mul(e,n))),t.ONE),o=t.inv(n);return e.reduceRight(((e,n,o)=>t.is0(n)?e:(r[o]=t.mul(e,r[o]),t.mul(e,n))),o),r}(a,t)},cmov(t,e,r){return r?e:t},toBytes(t){return r?F(t,i):z(t,i)},fromBytes(t){if(t.length!==i)throw Error("Field.fromBytes: expected "+i+" bytes, got "+t.length);return r?D(t):C(t)}});return Object.freeze(a)}function gt(t){if("bigint"!=typeof t)throw Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function mt(t){const e=gt(t);return e+Math.ceil(e/2)}const wt=BigInt(0),bt=BigInt(1);function Et(t,e){const r=e.negate();return t?r:e}function vt(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw Error("invalid window size, expected [1.."+e+"], got W="+t)}function Bt(t,e){vt(t,e);return{windows:Math.ceil(e/t)+1,windowSize:2**(t-1)}}const At=new WeakMap,xt=new WeakMap;function St(t){return xt.get(t)||1}function It(t,e,r,n){if(function(t,e){if(!Array.isArray(t))throw Error("array expected");t.forEach(((t,r)=>{if(!(t instanceof e))throw Error("invalid point at index "+r)}))}(r,t),function(t,e){if(!Array.isArray(t))throw Error("array of scalars expected");t.forEach(((t,r)=>{if(!e.isValid(t))throw Error("invalid scalar at index "+r)}))}(n,e),r.length!==n.length)throw Error("arrays of points and scalars must have equal length");const o=t.ZERO,i=M(BigInt(r.length)),s=i>12?i-3:i>4?i-2:i?2:1,a=(1<<s)-1,c=Array(a+1).fill(o);let u=o;for(let t=Math.floor((e.BITS-1)/s)*s;t>=0;t-=s){c.fill(o);for(let e=0;e<n.length;e++){const o=n[e],i=Number(o>>BigInt(t)&BigInt(a));c[i]=c[i].add(r[e])}let e=o;for(let t=c.length-1,r=o;t>0;t--)r=r.add(c[t]),e=e.add(r);if(u=u.add(e),0!==t)for(let t=0;t<s;t++)u=u.double()}return u}function kt(t){return Q(t.Fp,ht.reduce(((t,e)=>(t[e]="function",t)),{ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"})),Q(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...pt(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}function Pt(t){void 0!==t.lowS&&x("lowS",t.lowS),void 0!==t.prehash&&x("prehash",t.prehash)}const{bytesToNumberBE:Tt,hexToBytes:Ot}=tt;const Lt={Err:class extends Error{constructor(t=""){super(t)}},_tlv:{encode(t,e){const{Err:r}=Lt;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(1&e.length)throw new r("tlv.encode: unpadded data");const n=e.length/2,o=k(n);if(o.length/2&128)throw new r("tlv.encode: long form length too big");const i=n>127?k(o.length/2|128):"";return k(t)+i+o+e},decode(t,e){const{Err:r}=Lt;let n=0;if(t<0||t>256)throw new r("tlv.encode: wrong tag");if(e.length<2||e[n++]!==t)throw new r("tlv.decode: wrong tlv");const o=e[n++];let i=0;if(!!(128&o)){const t=127&o;if(!t)throw new r("tlv.decode(long): indefinite length not supported");if(t>4)throw new r("tlv.decode(long): byte length is too big");const s=e.subarray(n,n+t);if(s.length!==t)throw new r("tlv.decode: length bytes not complete");if(0===s[0])throw new r("tlv.decode(long): zero leftmost byte");for(const t of s)i=i<<8|t;if(n+=t,i<128)throw new r("tlv.decode(long): not minimal encoding")}else i=o;const s=e.subarray(n,n+i);if(s.length!==i)throw new r("tlv.decode: wrong value length");return{v:s,l:e.subarray(n+i)}}},_int:{encode(t){const{Err:e}=Lt;if(t<Rt)throw new e("integer: negative integers are not allowed");let r=k(t);if(8&Number.parseInt(r[0],16)&&(r="00"+r),1&r.length)throw new e("unexpected DER parsing assertion: unpadded hex");return r},decode(t){const{Err:e}=Lt;if(128&t[0])throw new e("invalid signature integer: negative");if(0===t[0]&&!(128&t[1]))throw new e("invalid signature integer: unnecessary leading zero");return Tt(t)}},toSig(t){const{Err:e,_int:r,_tlv:n}=Lt,o="string"==typeof t?Ot(t):t;A(o);const{v:i,l:s}=n.decode(48,o);if(s.length)throw new e("invalid signature: left bytes after parsing");const{v:a,l:c}=n.decode(2,i),{v:u,l:f}=n.decode(2,c);if(f.length)throw new e("invalid signature: left bytes after parsing");return{r:r.decode(a),s:r.decode(u)}},hexFromSig(t){const{_tlv:e,_int:r}=Lt,n=e.encode(2,r.encode(t.r))+e.encode(2,r.encode(t.s));return e.encode(48,n)}},Rt=BigInt(0),Ut=BigInt(1);BigInt(2);const Nt=BigInt(3);function qt(t){const e=function(t){const e=kt(t);Q(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:r,Fp:n,a:o}=e;if(r){if(!n.eql(o,n.ZERO))throw Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if("object"!=typeof r||"bigint"!=typeof r.beta||"function"!=typeof r.splitScalar)throw Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}(t),{Fp:r}=e,n=yt(e.n,e.nBitLength),o=e.toBytes||((t,e)=>{const n=e.toAffine();return V(Uint8Array.from([4]),r.toBytes(n.x),r.toBytes(n.y))}),i=e.fromBytes||(t=>{const e=t.subarray(1);return{x:r.fromBytes(e.subarray(0,r.BYTES)),y:r.fromBytes(e.subarray(r.BYTES,2*r.BYTES))}});function s(t){const{a:n,b:o}=e,i=r.sqr(t),s=r.mul(i,t);return r.add(r.add(s,r.mul(t,n)),o)}if(!r.eql(r.sqr(e.Gy),s(e.Gx)))throw Error("bad generator point: equation left != right");function a(t){const{allowedPrivateKeyLengths:r,nByteLength:n,wrapPrivateKey:o,n:i}=e;if(r&&"bigint"!=typeof t){if(B(t)&&(t=I(t)),"string"!=typeof t||!r.includes(t.length))throw Error("invalid private key");t=t.padStart(2*n,"0")}let s;try{s="bigint"==typeof t?t:C(j("private key",t,n))}catch(e){throw Error("invalid private key, expected hex or "+n+" bytes, got "+typeof t)}return o&&(s=ct(s,i)),_("private key",s,Ut,i),s}function c(t){if(!(t instanceof l))throw Error("ProjectivePoint expected")}const u=X(((t,e)=>{const{px:n,py:o,pz:i}=t;if(r.eql(i,r.ONE))return{x:n,y:o};const s=t.is0();null==e&&(e=s?r.ONE:r.inv(i));const a=r.mul(n,e),c=r.mul(o,e),u=r.mul(i,e);if(s)return{x:r.ZERO,y:r.ZERO};if(!r.eql(u,r.ONE))throw Error("invZ was invalid");return{x:a,y:c}})),f=X((t=>{if(t.is0()){if(e.allowInfinityPoint&&!r.is0(t.py))return;throw Error("bad point: ZERO")}const{x:n,y:o}=t.toAffine();if(!r.isValid(n)||!r.isValid(o))throw Error("bad point: x or y not FE");const i=r.sqr(o),a=s(n);if(!r.eql(i,a))throw Error("bad point: equation left != right");if(!t.isTorsionFree())throw Error("bad point: not in prime-order subgroup");return!0}));class l{constructor(t,e,n){if(this.px=t,this.py=e,this.pz=n,null==t||!r.isValid(t))throw Error("x required");if(null==e||!r.isValid(e))throw Error("y required");if(null==n||!r.isValid(n))throw Error("z required");Object.freeze(this)}static fromAffine(t){const{x:e,y:n}=t||{};if(!t||!r.isValid(e)||!r.isValid(n))throw Error("invalid affine point");if(t instanceof l)throw Error("projective point not allowed");const o=t=>r.eql(t,r.ZERO);return o(e)&&o(n)?l.ZERO:new l(e,n,r.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(t){const e=r.invertBatch(t.map((t=>t.pz)));return t.map(((t,r)=>t.toAffine(e[r]))).map(l.fromAffine)}static fromHex(t){const e=l.fromAffine(i(j("pointHex",t)));return e.assertValidity(),e}static fromPrivateKey(t){return l.BASE.multiply(a(t))}static msm(t,e){return It(l,n,t,e)}_setWindowSize(t){h.setWindowSize(this,t)}assertValidity(){f(this)}hasEvenY(){const{y:t}=this.toAffine();if(r.isOdd)return!r.isOdd(t);throw Error("Field doesn't support isOdd")}equals(t){c(t);const{px:e,py:n,pz:o}=this,{px:i,py:s,pz:a}=t,u=r.eql(r.mul(e,a),r.mul(i,o)),f=r.eql(r.mul(n,a),r.mul(s,o));return u&&f}negate(){return new l(this.px,r.neg(this.py),this.pz)}double(){const{a:t,b:n}=e,o=r.mul(n,Nt),{px:i,py:s,pz:a}=this;let c=r.ZERO,u=r.ZERO,f=r.ZERO,d=r.mul(i,i),h=r.mul(s,s),p=r.mul(a,a),y=r.mul(i,s);return y=r.add(y,y),f=r.mul(i,a),f=r.add(f,f),c=r.mul(t,f),u=r.mul(o,p),u=r.add(c,u),c=r.sub(h,u),u=r.add(h,u),u=r.mul(c,u),c=r.mul(y,c),f=r.mul(o,f),p=r.mul(t,p),y=r.sub(d,p),y=r.mul(t,y),y=r.add(y,f),f=r.add(d,d),d=r.add(f,d),d=r.add(d,p),d=r.mul(d,y),u=r.add(u,d),p=r.mul(s,a),p=r.add(p,p),d=r.mul(p,y),c=r.sub(c,d),f=r.mul(p,h),f=r.add(f,f),f=r.add(f,f),new l(c,u,f)}add(t){c(t);const{px:n,py:o,pz:i}=this,{px:s,py:a,pz:u}=t;let f=r.ZERO,d=r.ZERO,h=r.ZERO;const p=e.a,y=r.mul(e.b,Nt);let g=r.mul(n,s),m=r.mul(o,a),w=r.mul(i,u),b=r.add(n,o),E=r.add(s,a);b=r.mul(b,E),E=r.add(g,m),b=r.sub(b,E),E=r.add(n,i);let v=r.add(s,u);return E=r.mul(E,v),v=r.add(g,w),E=r.sub(E,v),v=r.add(o,i),f=r.add(a,u),v=r.mul(v,f),f=r.add(m,w),v=r.sub(v,f),h=r.mul(p,E),f=r.mul(y,w),h=r.add(f,h),f=r.sub(m,h),h=r.add(m,h),d=r.mul(f,h),m=r.add(g,g),m=r.add(m,g),w=r.mul(p,w),E=r.mul(y,E),m=r.add(m,w),w=r.sub(g,w),w=r.mul(p,w),E=r.add(E,w),g=r.mul(m,E),d=r.add(d,g),g=r.mul(v,E),f=r.mul(b,f),f=r.sub(f,g),g=r.mul(b,m),h=r.mul(v,h),h=r.add(h,g),new l(f,d,h)}subtract(t){return this.add(t.negate())}is0(){return this.equals(l.ZERO)}wNAF(t){return h.wNAFCached(this,t,l.normalizeZ)}multiplyUnsafe(t){const{endo:n,n:o}=e;_("scalar",t,Rt,o);const i=l.ZERO;if(t===Rt)return i;if(this.is0()||t===Ut)return this;if(!n||h.hasPrecomputes(this))return h.wNAFCachedUnsafe(this,t,l.normalizeZ);let{k1neg:s,k1:a,k2neg:c,k2:u}=n.splitScalar(t),f=i,d=i,p=this;for(;a>Rt||u>Rt;)a&Ut&&(f=f.add(p)),u&Ut&&(d=d.add(p)),p=p.double(),a>>=Ut,u>>=Ut;return s&&(f=f.negate()),c&&(d=d.negate()),d=new l(r.mul(d.px,n.beta),d.py,d.pz),f.add(d)}multiply(t){const{endo:n,n:o}=e;let i,s;if(_("scalar",t,Ut,o),n){const{k1neg:e,k1:o,k2neg:a,k2:c}=n.splitScalar(t);let{p:u,f}=this.wNAF(o),{p:d,f:p}=this.wNAF(c);u=h.constTimeNegate(e,u),d=h.constTimeNegate(a,d),d=new l(r.mul(d.px,n.beta),d.py,d.pz),i=u.add(d),s=f.add(p)}else{const{p:e,f:r}=this.wNAF(t);i=e,s=r}return l.normalizeZ([i,s])[0]}multiplyAndAddUnsafe(t,e,r){const n=l.BASE,o=(t,e)=>e!==Rt&&e!==Ut&&t.equals(n)?t.multiply(e):t.multiplyUnsafe(e),i=o(this,e).add(o(t,r));return i.is0()?void 0:i}toAffine(t){return u(this,t)}isTorsionFree(){const{h:t,isTorsionFree:r}=e;if(t===Ut)return!0;if(r)return r(l,this);throw Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:t,clearCofactor:r}=e;return t===Ut?this:r?r(l,this):this.multiplyUnsafe(e.h)}toRawBytes(t=!0){return x("isCompressed",t),this.assertValidity(),o(l,this,t)}toHex(t=!0){return x("isCompressed",t),I(this.toRawBytes(t))}}l.BASE=new l(e.Gx,e.Gy,r.ONE),l.ZERO=new l(r.ZERO,r.ONE,r.ZERO);const d=e.nBitLength,h=(p=l,y=e.endo?Math.ceil(d/2):d,{constTimeNegate:Et,hasPrecomputes:t=>1!==St(t),unsafeLadder(t,e,r=p.ZERO){let n=t;for(;e>wt;)e&bt&&(r=r.add(n)),n=n.double(),e>>=bt;return r},precomputeWindow(t,e){const{windows:r,windowSize:n}=Bt(e,y),o=[];let i=t,s=i;for(let t=0;t<r;t++){s=i,o.push(s);for(let t=1;t<n;t++)s=s.add(i),o.push(s);i=s.double()}return o},wNAF(t,e,r){const{windows:n,windowSize:o}=Bt(t,y);let i=p.ZERO,s=p.BASE;const a=BigInt(2**t-1),c=2**t,u=BigInt(t);for(let t=0;t<n;t++){const n=t*o;let f=Number(r&a);r>>=u,f>o&&(f-=c,r+=bt);const l=n,d=n+Math.abs(f)-1,h=t%2!=0,p=f<0;0===f?s=s.add(Et(h,e[l])):i=i.add(Et(p,e[d]))}return{p:i,f:s}},wNAFUnsafe(t,e,r,n=p.ZERO){const{windows:o,windowSize:i}=Bt(t,y),s=BigInt(2**t-1),a=2**t,c=BigInt(t);for(let t=0;t<o;t++){const o=t*i;if(r===wt)break;let u=Number(r&s);if(r>>=c,u>i&&(u-=a,r+=bt),0===u)continue;let f=e[o+Math.abs(u)-1];u<0&&(f=f.negate()),n=n.add(f)}return n},getPrecomputes(t,e,r){let n=At.get(e);return n||(n=this.precomputeWindow(e,t),1!==t&&At.set(e,r(n))),n},wNAFCached(t,e,r){const n=St(t);return this.wNAF(n,this.getPrecomputes(n,t,r),e)},wNAFCachedUnsafe(t,e,r,n){const o=St(t);return 1===o?this.unsafeLadder(t,e,n):this.wNAFUnsafe(o,this.getPrecomputes(o,t,r),e,n)},setWindowSize(t,e){vt(e,y),xt.set(t,e),At.delete(t)}});var p,y;return{CURVE:e,ProjectivePoint:l,normPrivateKeyToScalar:a,weierstrassEquation:s,isWithinCurveOrder(t){return K(t,Ut,e.n)}}}function Ht(t){const e=function(t){const e=kt(t);return Q(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}(t),{Fp:r,n}=e,o=r.BYTES+1,i=2*r.BYTES+1;function s(t){return ct(t,n)}function a(t){return lt(t,n)}const{ProjectivePoint:c,normPrivateKeyToScalar:u,weierstrassEquation:f,isWithinCurveOrder:l}=qt({...e,toBytes(t,e,n){const o=e.toAffine(),i=r.toBytes(o.x),s=V;return x("isCompressed",n),n?s(Uint8Array.from([e.hasEvenY()?2:3]),i):s(Uint8Array.from([4]),i,r.toBytes(o.y))},fromBytes(t){const e=t.length,n=t[0],s=t.subarray(1);if(e!==o||2!==n&&3!==n){if(e===i&&4===n){return{x:r.fromBytes(s.subarray(0,r.BYTES)),y:r.fromBytes(s.subarray(r.BYTES,2*r.BYTES))}}throw Error("invalid Point, expected length of "+o+", or uncompressed "+i+", got "+e)}{const t=C(s);if(!K(t,Ut,r.ORDER))throw Error("Point is not on curve");const e=f(t);let o;try{o=r.sqrt(e)}catch(t){const e=t instanceof Error?": "+t.message:"";throw Error("Point is not on curve"+e)}return!(1&~n)!==((o&Ut)===Ut)&&(o=r.neg(o)),{x:t,y:o}}}}),d=t=>I(z(t,e.nByteLength));function h(t){return t>n>>Ut}const p=(t,e,r)=>C(t.slice(e,r));class y{constructor(t,e,r){this.r=t,this.s=e,this.recovery=r,this.assertValidity()}static fromCompact(t){const r=e.nByteLength;return t=j("compactSignature",t,2*r),new y(p(t,0,r),p(t,r,2*r))}static fromDER(t){const{r:e,s:r}=Lt.toSig(j("DER",t));return new y(e,r)}assertValidity(){_("r",this.r,Ut,n),_("s",this.s,Ut,n)}addRecoveryBit(t){return new y(this.r,this.s,t)}recoverPublicKey(t){const{r:n,s:o,recovery:i}=this,u=b(j("msgHash",t));if(null==i||![0,1,2,3].includes(i))throw Error("recovery id invalid");const f=2===i||3===i?n+e.n:n;if(f>=r.ORDER)throw Error("recovery id 2 or 3 invalid");const l=1&i?"03":"02",h=c.fromHex(l+d(f)),p=a(f),y=s(-u*p),g=s(o*p),m=c.BASE.multiplyAndAddUnsafe(h,y,g);if(!m)throw Error("point at infinify");return m.assertValidity(),m}hasHighS(){return h(this.s)}normalizeS(){return this.hasHighS()?new y(this.r,s(-this.s),this.recovery):this}toDERRawBytes(){return H(this.toDERHex())}toDERHex(){return Lt.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return H(this.toCompactHex())}toCompactHex(){return d(this.r)+d(this.s)}}const g={isValidPrivateKey(t){try{return u(t),!0}catch(t){return!1}},normPrivateKeyToScalar:u,randomPrivateKey(){const t=mt(e.n);return function(t,e,r=!1){const n=t.length,o=gt(e),i=mt(e);if(n<16||n<i||n>1024)throw Error("expected "+i+"-1024 bytes of input, got "+n);const s=ct(r?D(t):C(t),e-rt)+rt;return r?F(s,o):z(s,o)}(e.randomBytes(t),e.n)},precompute:(t=8,e=c.BASE)=>(e._setWindowSize(t),e.multiply(BigInt(3)),e)};function m(t){const e=B(t),r="string"==typeof t,n=(e||r)&&t.length;return e?n===o||n===i:r?n===2*o||n===2*i:t instanceof c}const w=e.bits2int||(t=>{if(t.length>8192)throw Error("input is too large");const r=C(t),n=8*t.length-e.nBitLength;return n>0?r>>BigInt(n):r}),b=e.bits2int_modN||(t=>s(w(t))),E=G(e.nBitLength);function v(t){return _("num < 2^"+e.nBitLength,t,Rt,E),z(t,e.nByteLength)}function A(t,n,o=S){if(["recovered","canonical"].some((t=>t in o)))throw Error("sign() legacy options not supported");const{hash:i,randomBytes:f}=e;let{lowS:d,prehash:p,extraEntropy:g}=o;null==d&&(d=!0),t=j("msgHash",t),Pt(o),p&&(t=j("prehashed msgHash",i(t)));const m=b(t),E=u(n),B=[v(E),v(m)];if(null!=g&&!1!==g){const t=!0===g?f(r.BYTES):g;B.push(j("extraEntropy",t))}const A=V(...B),x=m;return{seed:A,k2sig(t){const e=w(t);if(!l(e))return;const r=a(e),n=c.BASE.multiply(e).toAffine(),o=s(n.x);if(o===Rt)return;const i=s(r*s(x+o*E));if(i===Rt)return;let u=(n.x===o?0:2)|Number(n.y&Ut),f=i;return d&&h(i)&&(f=function(t){return h(t)?s(-t):t}(i),u^=1),new y(o,f,u)}}}const S={lowS:e.lowS,prehash:!1},k={lowS:e.lowS,prehash:!1};return c.BASE._setWindowSize(8),{CURVE:e,getPublicKey(t,e=!0){return c.fromPrivateKey(t).toRawBytes(e)},getSharedSecret(t,e,r=!0){if(m(t))throw Error("first arg must be private key");if(!m(e))throw Error("second arg must be public key");return c.fromHex(e).multiply(u(t)).toRawBytes(r)},sign(t,r,n=S){const{seed:o,k2sig:i}=A(t,r,n),s=e;return W(s.hash.outputLen,s.nByteLength,s.hmac)(o,i)},verify(t,r,n,o=k){const i=t;r=j("msgHash",r),n=j("publicKey",n);const{lowS:u,prehash:f,format:l}=o;if(Pt(o),"strict"in o)throw Error("options.strict was renamed to lowS");if(void 0!==l&&"compact"!==l&&"der"!==l)throw Error("format must be compact or der");const d="string"==typeof i||B(i),h=!d&&!l&&"object"==typeof i&&null!==i&&"bigint"==typeof i.r&&"bigint"==typeof i.s;if(!d&&!h)throw Error("invalid signature, expected Uint8Array, hex string or Signature instance");let p,g;try{if(h&&(p=new y(i.r,i.s)),d){try{"compact"!==l&&(p=y.fromDER(i))}catch(t){if(!(t instanceof Lt.Err))throw t}p||"der"===l||(p=y.fromCompact(i))}g=c.fromHex(n)}catch(t){return!1}if(!p)return!1;if(u&&p.hasHighS())return!1;f&&(r=e.hash(r));const{r:m,s:w}=p,E=b(r),v=a(w),A=s(E*v),x=s(m*v),S=c.BASE.multiplyAndAddUnsafe(g,A,x)?.toAffine();return!!S&&s(S.x)===m},ProjectivePoint:c,Signature:y,utils:g}}function Ct(t){return{hash:t,hmac(r,...n){return w(t,r,function(...t){let r=0;for(let n=0;n<t.length;n++){const o=t[n];e(o),r+=o.length}const n=new Uint8Array(r);for(let e=0,r=0;e<t.length;e++){const o=t[e];n.set(o,r),r+=o.length}return n}(...n))},randomBytes:u}}BigInt(4);const Dt=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),zt=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),Ft=BigInt(1),jt=BigInt(2),Vt=(t,e)=>(t+e/jt)/e;function Zt(t){const e=Dt,r=BigInt(3),n=BigInt(6),o=BigInt(11),i=BigInt(22),s=BigInt(23),a=BigInt(44),c=BigInt(88),u=t*t*t%e,f=u*u*t%e,l=ft(f,r,e)*f%e,d=ft(l,r,e)*f%e,h=ft(d,jt,e)*u%e,p=ft(h,o,e)*h%e,y=ft(p,i,e)*p%e,g=ft(y,a,e)*y%e,m=ft(g,c,e)*g%e,w=ft(m,a,e)*y%e,b=ft(w,r,e)*f%e,E=ft(b,s,e)*p%e,v=ft(E,n,e)*u%e,B=ft(v,jt,e);if(!Kt.eql(Kt.sqr(B),t))throw Error("Cannot find square root");return B}const Kt=yt(Dt,void 0,void 0,{sqrt:Zt}),_t=function(t,e){const r=e=>Ht({...t,...Ct(e)});return{...r(e),create:r}}({a:BigInt(0),b:BigInt(7),Fp:Kt,n:zt,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar(t){const e=zt,r=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),n=-Ft*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),o=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),i=r,s=BigInt("0x100000000000000000000000000000000"),a=Vt(i*t,e),c=Vt(-n*t,e);let u=ct(t-a*r-c*o,e),f=ct(-a*n-c*i,e);const l=u>s,d=f>s;if(l&&(u=e-u),d&&(f=e-f),u>s||f>s)throw Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:l,k1:u,k2neg:d,k2:f}}}},g),Mt=BigInt(0),Gt={};function $t(t,...e){let r=Gt[t];if(void 0===r){const e=g(Uint8Array.from(t,(t=>t.charCodeAt(0))));r=V(e,e),Gt[t]=r}return g(V(r,...e))}const Yt=t=>t.toRawBytes(!0).slice(1),Wt=t=>z(t,32),Jt=t=>ct(t,Dt),Qt=t=>ct(t,zt),Xt=_t.ProjectivePoint;function te(t){let e=_t.utils.normPrivateKeyToScalar(t),r=Xt.fromPrivateKey(e);return{scalar:r.hasEvenY()?e:Qt(-e),bytes:Yt(r)}}function ee(t){_("x",t,Ft,Dt);const e=Jt(t*t);let r=Zt(Jt(e*t+BigInt(7)));r%jt!==Mt&&(r=Jt(-r));const n=new Xt(t,r,Ft);return n.assertValidity(),n}const re=C;function ne(...t){return Qt(re($t("BIP0340/challenge",...t)))}function oe(t){return te(t).bytes}function ie(t,e,r=u(32)){const n=j("message",t),{bytes:o,scalar:i}=te(e),s=j("auxRand",r,32),a=Wt(i^re($t("BIP0340/aux",s))),c=$t("BIP0340/nonce",a,o,n),f=Qt(re(c));if(f===Mt)throw Error("sign failed: k is zero");const{bytes:l,scalar:d}=te(f),h=ne(l,o,n),p=new Uint8Array(64);if(p.set(l,0),p.set(Wt(Qt(d+h*i)),32),!se(p,n,o))throw Error("sign: Invalid signature produced");return p}function se(t,e,r){const n=j("signature",t,64),o=j("message",e),i=j("publicKey",r,32);try{const t=ee(re(i)),e=re(n.subarray(0,32));if(!K(e,Ft,Dt))return!1;const r=re(n.subarray(32,64));if(!K(r,Ft,zt))return!1;const u=ne(Wt(e),Yt(t),o),f=(s=t,a=r,c=Qt(-u),Xt.BASE.multiplyAndAddUnsafe(s,a,c));return!(!f||!f.hasEvenY()||f.toAffine().x!==e)}catch(t){return!1}var s,a,c}const ae=(()=>({getPublicKey:oe,sign:ie,verify:se,utils:{randomPrivateKey:_t.utils.randomPrivateKey,lift_x:ee,pointToBytes:Yt,numberToBytesBE:z,bytesToNumberBE:C,taggedHash:$t,mod:ct}}))(),{floor:ce,random:ue,sin:fe}=Math,le="Trystero",de=(t,e)=>Array(t).fill().map(e),he="0123456789AaBbCcDdEeFfGgHhIiJjKkLlMmNnOoPpQqRrSsTtUuVvWwXxYyZz",pe=t=>de(t,(()=>he[ce(62*ue())])).join(""),ye=pe(20),ge=Promise.all.bind(Promise),me="undefined"!=typeof window,{entries:we,fromEntries:be,keys:Ee}=Object,ve=()=>{},Be=t=>Error(`${le}: ${t}`),Ae=new TextEncoder,xe=new TextDecoder,Se=t=>Ae.encode(t),Ie=t=>xe.decode(t),ke=t=>t.reduce(((t,e)=>t+e.toString(16).padStart(2,"0")),""),Pe=(...t)=>t.join("@"),Te=(t,e,r)=>(t.relayUrls||((t,e)=>{const r=[...t],n=()=>{const t=1e4*fe(e++);return t-ce(t)};let o=r.length;for(;o;){const t=ce(n()*o--);[r[o],r[t]]=[r[t],r[o]]}return r})(e,Re(t.appId))).slice(0,t.relayUrls?t.relayUrls.length:t.relayRedundancy||r),Oe=JSON.stringify,Le=JSON.parse,Re=(t,e=Number.MAX_SAFE_INTEGER)=>t.split("").reduce(((t,e)=>t+e.charCodeAt(0)),0)%e,Ue={},Ne="AES-GCM",qe={},He=async t=>qe[t]||(qe[t]=Array.from(new Uint8Array(await crypto.subtle.digest("SHA-1",Se(t)))).map((t=>t.toString(36))).join("")),Ce=async(t,e)=>{const r=crypto.getRandomValues(new Uint8Array(16));return r.join(",")+"$"+(n=await crypto.subtle.encrypt({name:Ne,iv:r},await t,Se(e)),btoa(String.fromCharCode.apply(null,new Uint8Array(n))));var n},De=async(t,e)=>{const[r,n]=e.split("$");return Ie(await crypto.subtle.decrypt({name:Ne,iv:new Uint8Array(r.split(","))},await t,(t=>{const e=atob(t);return new Uint8Array(e.length).map(((t,r)=>e.charCodeAt(r))).buffer})(n)))},ze="icegatheringstatechange",Fe=t=>t.replace(/a=ice-options:trickle\s\n/g,"");var je=(t,{rtcConfig:e,rtcPolyfill:r,turnConfig:n})=>{const o=new(r||RTCPeerConnection)({iceServers:Ve.concat(n||[]),...e}),i={},s=t=>{t.binaryType="arraybuffer",t.bufferedAmountLowThreshold=65535,t.onmessage=t=>i.data?.(t.data),t.onopen=()=>i.connect?.(),t.onclose=()=>i.close?.(),t.onerror=t=>i.error?.(t)},a=async t=>{if(!t.localDescription)throw Error("No local description available");return await Promise.race([new Promise((e=>{const r=()=>{"complete"===t.iceGatheringState&&(t.removeEventListener(ze,r),e())};t.addEventListener(ze,r),r()})),new Promise((t=>setTimeout(t,5e3)))]),{type:t.localDescription.type,sdp:Fe(t.localDescription.sdp)}};let c=!1,u=null,f=!1;return t?(u=o.createDataChannel("data"),s(u)):o.ondatachannel=({channel:t})=>{u=t,s(t)},o.onnegotiationneeded=async()=>{try{c=!0,await o.setLocalDescription();const t=await a(o);i.signal?.({type:t.type,sdp:Fe(t.sdp)})}catch(t){i.error?.(t)}finally{c=!1}},o.onconnectionstatechange=()=>{["disconnected","failed","closed"].includes(o.connectionState)&&i.close?.()},o.ontrack=t=>{i.track?.(t.track,t.streams[0]),i.stream?.(t.streams[0])},o.onremovestream=t=>{i.stream?.(t.stream,{removed:!0})},{created:Date.now(),connection:o,get channel(){return u},get isDead(){return"closed"===o.connectionState},async signal(e){if("open"!==u?.readyState)try{if("offer"===e.type){if((c||"stable"!==o.signalingState)&&(f=!t,f))return;await o.setRemoteDescription(e),await o.setLocalDescription();const r=await a(o),n=Fe(r.sdp);return i.signal?.({type:r.type,sdp:n}),{type:r.type,sdp:n}}"answer"!==e.type||"have-local-offer"!==o.signalingState&&"have-remote-offer"!==o.signalingState||await o.setRemoteDescription(e)}catch(t){i.error?.(t)}else if(("offer"===e.type||"stable"!==o.signalingState)&&(await o.setRemoteDescription(e),"offer"===e.type)){await o.setLocalDescription();const t=await a(o);return i.signal?.({type:t.type,sdp:t.sdp}),{type:t.type,sdp:t.sdp}}},sendData(t){return u.send(t)},destroy(){u&&u.close(),o.close()},setHandlers(t){return Object.assign(i,t)},offerPromise:t?new Promise((t=>{i.signal=e=>{"offer"===e.type&&t(e)}})):Promise.resolve(),addStream(t){t.getTracks().forEach((e=>o.addTrack(e,t)))},removeStream(t){o.getSenders().filter((e=>t.getTracks().includes(e.track))).forEach((t=>o.removeTrack(t)))},addTrack(t,e){return o.addTrack(t,e)},removeTrack(t){const e=o.getSenders().find((e=>e.track===t));e&&o.removeTrack(e)},async replaceTrack(t,e){const r=o.getSenders().find((e=>e.track===t));r&&await r.replaceTrack(e)}}};const Ve=[...de(3,((t,e)=>`stun:stun${e||""}.l.google.com:19302`)),"stun:global.stun.twilio.com:3478"].map((t=>({urls:t}))),Ze=Object.getPrototypeOf(Uint8Array),Ke=16369,_e=255,Me="bufferedamountlow",Ge=t=>"@_"+t;const $e={},Ye="EVENT",We=ae.utils.randomPrivateKey(),Je=ke(ae.getPublicKey(We)),Qe={},Xe={},tr={},er=()=>Math.floor(Date.now()/1e3),rr=t=>tr[t]??=Re(t,1e4)+2e4,nr=async(t,e)=>{const r={kind:rr(t),content:e,pubkey:Je,created_at:er(),tags:[["x",t]]},n=ke(new Uint8Array(await crypto.subtle.digest("SHA-256",Se(Oe([0,r.pubkey,r.created_at,r.kind,r.tags,r.content])))));return Oe([Ye,{...r,id:n,sig:ke(await ae.sign(n,We))}])},or=(t,e)=>(Qe[t]=e,Oe(["REQ",t,{kinds:[rr(e)],since:er(),"#x":[e]}])),ir=t=>(delete Qe[t],Oe(["CLOSE",t])),sr=(({init:t,subscribe:e,announce:r})=>{const n={};let o,i,s,a=!1;return(c,u,f)=>{const{appId:l}=c;if(n[l]?.[u])return n[l][u];const d={},h={},p=Pe(le,l,u),y=He(p),g=He(Pe(p,ye)),m=(async(t,e,r)=>crypto.subtle.importKey("raw",await crypto.subtle.digest({name:"SHA-256"},Se(`${t}:${e}:${r}`)),{name:Ne},!1,["encrypt","decrypt"]))(c.password||"",l,u),w=t=>async e=>({type:e.type,sdp:await t(m,e.sdp)}),b=w(De),E=w(Ce),v=()=>je(!0,c),B=(t,e,r)=>{h[e]?h[e]!==t&&t.destroy():(h[e]=t,O(t,e),d[e]?.forEach(((t,e)=>{e!==r&&t.destroy()})),delete d[e])},A=(t,e)=>{h[e]===t&&delete h[e]},x=t=>(i.push(...de(t,v)),ge(i.splice(0,t).map((t=>t.offerPromise.then(E).then((e=>({peer:t,offer:e}))))))),S=(t,e)=>f?.({error:`incorrect password (${c.password}) when decrypting ${e}`,appId:l,peerId:t,roomId:u}),I=t=>async(e,r,n)=>{const[o,i]=await ge([y,g]);if(e!==o&&e!==i)return;const{peerId:s,offer:a,answer:u,peer:f}="string"==typeof r?Le(r):r;if(s!==ye&&!h[s])if(!s||a||u){if(a){const e=d[s]?.[t];if(e&&ye>s)return;const r=je(!1,c);let o;r.setHandlers({connect(){return B(r,s,t)},close(){return A(r,s)}});try{o=await b(a)}catch{return void S(s,"offer")}if(r.isDead)return;const[i,u]=await ge([He(Pe(p,s)),r.signal(o)]);n(i,Oe({peerId:ye,answer:await E(u)}))}else if(u){let e;try{e=await b(u)}catch(t){return void S(s,"answer")}if(f)f.setHandlers({connect(){return B(f,s,t)},close(){return A(f,s)}}),f.signal(e);else{const r=d[s]?.[t];r&&!r.isDead&&r.signal(e)}}}else{if(d[s]?.[t])return;const[[{peer:e,offer:r}],o]=await ge([x(1),He(Pe(p,s))]);d[s]||=[],d[s][t]=e,setTimeout((()=>((t,e)=>{if(h[t])return;const r=d[t]?.[e];r&&(delete d[t][e],r.destroy())})(s,t)),.9*k[t]),e.setHandlers({connect(){return B(e,s,t)},close(){return A(e,s)}}),n(o,Oe({peerId:ye,offer:r}))}};if(!c)throw Be("requires a config map as the first argument");if(!l&&!c.firebaseApp)throw Be("config map is missing appId field");if(!u)throw Be("roomId argument required");if(!a){const e=t(c);i=de(20,v),o=Array.isArray(e)?e:[e],a=!0,s=setInterval((()=>i=i.filter((t=>{const e=Date.now()-t.created<57333;return e||t.destroy(),e}))),59052.99)}const k=o.map((()=>5333)),P=[],T=o.map((async(t,r)=>e(await t,await y,await g,I(r),x)));ge([y,g]).then((([t,e])=>{const n=async(o,i)=>{const s=await r(o,t,e);"number"==typeof s&&(k[i]=s),P[i]=setTimeout((()=>n(o,i)),k[i])};T.forEach((async(t,e)=>{await t,n(await o[e],e)}))}));let O=ve;return n[l]||={},n[l][u]=((t,e,r)=>{const n={},o={},i={},s={},a={},c={},u={},f={onPeerJoin:ve,onPeerLeave:ve,onPeerStream:ve,onPeerTrack:ve},l=(t,e)=>(t?Array.isArray(t)?t:[t]:Ee(n)).flatMap((t=>{const r=n[t];return r?e(t,r):(console.warn(`${le}: no peer with id ${t} found`),[])})),d=t=>{n[t]&&(delete n[t],delete s[t],delete a[t],f.onPeerLeave(t),e(t))},h=t=>{if(o[t])return i[t];if(!t)throw Be("action type argument is required");const e=Se(t);if(e.byteLength>12)throw Be(`action type string "${t}" (${e.byteLength}b) exceeds byte limit (12). Hint: choose a shorter name.`);const r=new Uint8Array(12);r.set(e);let s=0;return o[t]={onComplete:ve,onProgress:ve,setOnComplete:e=>o[t]={...o[t],onComplete:e},setOnProgress:e=>o[t]={...o[t],onProgress:e},async send(t,e,o,i){if(o&&"object"!=typeof o)throw Be("action meta argument must be an object");const a=typeof t;if("undefined"===a)throw Be("action data cannot be undefined");const c="string"!==a,u=t instanceof Blob,f=u||t instanceof ArrayBuffer||t instanceof Ze;if(o&&!f)throw Be("action meta argument can only be used with binary data");const d=f?new Uint8Array(u?await t.arrayBuffer():t):Se(c?Oe(t):t),h=o?Se(Oe(o)):null,p=Math.ceil(d.byteLength/Ke)+(o?1:0)||1,y=de(p,((t,e)=>{const n=e===p-1,i=o&&0===e,a=new Uint8Array(15+(i?h.byteLength:n?d.byteLength-Ke*(p-(o?2:1)):Ke));return a.set(r),a.set([s],12),a.set([n|i<<1|f<<2|c<<3],13),a.set([Math.round((e+1)/p*_e)],14),a.set(o?i?h:d.subarray((e-1)*Ke,e*Ke):d.subarray(e*Ke,(e+1)*Ke),15),a}));return s=s+1&_e,ge(l(e,(async(t,e)=>{const{channel:r}=e;let s=0;for(;s<p;){const a=y[s];if(r.bufferedAmount>r.bufferedAmountLowThreshold&&await new Promise((t=>{const e=()=>{r.removeEventListener(Me,e),t()};r.addEventListener(Me,e)})),!n[t])break;e.sendData(a),s++,i?.(a[14]/_e,t,o)}})))}},i[t]||=[o[t].send,o[t].setOnComplete,o[t].setOnProgress]},p=(t,e)=>{const r=new Uint8Array(e),n=Ie(r.subarray(0,12)).replaceAll("\0",""),[i]=r.subarray(12,13),[a]=r.subarray(13,14),[c]=r.subarray(14,15),u=r.subarray(15),f=!!(1&a),l=!!(2&a),d=!!(4&a),h=!!(8&a);if(!o[n])return void console.warn(`${le}: received message with unregistered type (${n})`);s[t]||={},s[t][n]||={};const p=s[t][n][i]||={chunks:[]};if(l?p.meta=Le(Ie(u)):p.chunks.push(u),o[n].onProgress(c/_e,t,p.meta),!f)return;const y=new Uint8Array(p.chunks.reduce(((t,e)=>t+e.byteLength),0));if(p.chunks.reduce(((t,e)=>(y.set(e,t),t+e.byteLength)),0),delete s[t][n][i],d)o[n].onComplete(y,t,p.meta);else{const e=Ie(y);o[n].onComplete(h?Le(e):e,t)}},y=async()=>{await I(""),await new Promise((t=>setTimeout(t,99))),we(n).forEach((([t,e])=>{e.destroy(),delete n[t]})),r()},[g,m]=h(Ge("ping")),[w,b]=h(Ge("pong")),[E,v]=h(Ge("signal")),[B,A]=h(Ge("stream")),[x,S]=h(Ge("track")),[I,k]=h(Ge("leave"));return t(((t,e)=>{n[e]||(n[e]=t,t.setHandlers({data:t=>p(e,t),stream(t){f.onPeerStream(t,e,c[e]),delete c[e]},track(t,r){f.onPeerTrack(t,r,e,u[e]),delete u[e]},signal:t=>E(t,e),close:()=>d(e),error:()=>d(e)}),f.onPeerJoin(e),t.drainEarlyData?.((t=>p(e,t))))})),m(((t,e)=>w("",e))),b(((t,e)=>{a[e]?.(),delete a[e]})),v(((t,e)=>n[e]?.signal(t))),A(((t,e)=>c[e]=t)),S(((t,e)=>u[e]=t)),k(((t,e)=>d(e))),me&&addEventListener("beforeunload",y),{makeAction:h,leave:y,async ping(t){if(!t)throw Be("ping() must be called with target peer ID");const e=Date.now();return g("",t),await new Promise((e=>a[t]=e)),Date.now()-e},getPeers:()=>be(we(n).map((([t,e])=>[t,e.connection]))),addStream:(t,e,r)=>l(e,(async(e,n)=>{r&&await B(r,e),n.addStream(t)})),removeStream:(t,e)=>l(e,((e,r)=>r.removeStream(t))),addTrack:(t,e,r,n)=>l(r,(async(r,o)=>{n&&await x(n,r),o.addTrack(t,e)})),removeTrack:(t,e,r)=>l(r,((r,n)=>n.removeTrack(t,e))),replaceTrack:(t,e,r,n,o)=>l(n,(async(n,i)=>{o&&await x(o,n),i.replaceTrack(t,e,r)})),onPeerJoin:t=>f.onPeerJoin=t,onPeerLeave:t=>f.onPeerLeave=t,onPeerStream:t=>f.onPeerStream=t,onPeerTrack:t=>f.onPeerTrack=t}})((t=>O=t),(t=>delete h[t]),(()=>{delete n[l][u],P.forEach(clearTimeout),T.forEach((async t=>(await t)())),clearInterval(s)}))}})({init(t){return Te(t,ur,5).map((t=>{const e=((t,e)=>{const r={},n=()=>{const o=new WebSocket(t);o.onclose=()=>{Ue[t]??=3333,setTimeout(n,Ue[t]),Ue[t]*=2},o.onmessage=t=>e(t.data),r.socket=o,r.url=o.url,r.ready=new Promise((e=>o.onopen=()=>{e(r),Ue[t]=3333})),r.send=t=>{1===o.readyState&&o.send(t)}};return n(),r})(t,(t=>{const[r,n,o,i]=Le(t);if(r===Ye)Xe[n]?.(Qe[n],o.content);else{const t=`${le}: relay failure from ${e.url} - `;"NOTICE"===r?console.warn(t+n):"OK"!==r||o||console.warn(t+i)}}));return $e[t]=e,e.ready}))},subscribe(t,e,r,n){const o=pe(64),i=pe(64);return Xe[o]=Xe[i]=(e,r)=>n(e,r,(async(e,r)=>t.send(await nr(e,r)))),t.send(or(o,e)),t.send(or(i,r)),()=>{t.send(ir(o)),t.send(ir(i)),delete Xe[o],delete Xe[i]}},async announce(t,e){return t.send(await nr(e,Oe({peerId:ye})))}}),ar=(cr=$e,()=>be(we(cr).map((([t,e])=>[t,e.socket]))));var cr;const ur=["eu.purplerelay.com","ftp.halifax.rwth-aachen.de/nostr","longhorn.bgp.rodeo","multiplexer.huszonegy.world","nfdb.noswhere.com","nostr-verified.wellorder.net","nostr.cool110.xyz","nostr.data.haus","nostr.grooveix.com","nostr.huszonegy.world","nostr.mom","nostr.openhoofd.nl","nostr.petrkr.net/strfry","nostr.sathoarder.com","nostr.stakey.net","nostr.vulpem.com","nostr2.sanhauf.com","nostrelay.circum.space","relay.fountain.fm","relay.nostraddress.com","relay.nostromo.social","relay.snort.social","relay.verified-nostr.com","strfry.openhoofd.nl","yabu.me/v2"].map((t=>"wss://"+t));export{ur as defaultRelayUrls,ar as getRelaySockets,sr as joinRoom,ye as selfId};